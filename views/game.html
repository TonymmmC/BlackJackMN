<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blackjack + M√©todos Num√©ricos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0c4a6e, #1e293b);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .game-area {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            margin-bottom: 30px;
        }

        .table {
            background: #065f46;
            border-radius: 20px;
            padding: 30px;
            position: relative;
            min-height: 500px;
        }

        .hand {
            margin: 20px 0;
        }

        .cards {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 15px 0;
        }

        .card {
            width: 60px;
            height: 90px;
            background: white;
            color: black;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            font-weight: bold;
            font-size: 12px;
            transition: transform 0.3s;
        }

        .card:hover {
            transform: scale(1.05);
        }

        .card.hearts, .card.diamonds {
            color: #dc2626;
        }

        .card.clubs, .card.spades {
            color: #1f2937;
        }

        .sidebar {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: #059669;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        button:hover:not(:disabled) {
            background: #047857;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(5, 150, 105, 0.4);
        }

        button:disabled {
            background: #6b7280;
            cursor: not-allowed;
            transform: none;
            opacity: 0.5;
        }

        .stats {
            margin: 20px 0;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }

        .recommendation {
            background: rgba(34, 197, 94, 0.2);
            border: 2px solid #22c55e;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            transition: all 0.3s;
        }

        .recommendation.hit {
            border-color: #f59e0b;
            background: rgba(245, 158, 11, 0.2);
        }

        .recommendation.stand {
            border-color: #ef4444;
            background: rgba(239, 68, 68, 0.2);
        }

        .recommendation.double {
            border-color: #8b5cf6;
            background: rgba(139, 92, 246, 0.2);
        }

        .numeric-analysis {
            margin-top: 20px;
            font-size: 12px;
        }

        .analysis-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 4px;
            background: rgba(255,255,255,0.05);
            border-radius: 3px;
        }

        #probabilityChart {
            margin-top: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 10px;
        }

        .bet-input {
            margin: 15px 0;
            text-align: center;
        }

        input[type="number"] {
            padding: 10px;
            border-radius: 5px;
            border: 2px solid #374151;
            width: 100%;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 16px;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #059669;
        }

        .game-info {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }

        .balance {
            font-size: 28px;
            font-weight: bold;
            color: #fbbf24;
            margin: 10px 0;
        }

        .totals {
            font-size: 18px;
            margin: 10px 0;
            font-weight: bold;
        }

        .hidden {
            display: none;
        }

        .animation {
            animation: fadeInScale 0.5s ease-out;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .game-status {
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }

        .game-status.win {
            background: rgba(34, 197, 94, 0.3);
            border: 2px solid #22c55e;
        }

        .game-status.loss {
            background: rgba(239, 68, 68, 0.3);
            border: 2px solid #ef4444;
        }

        .game-status.draw {
            background: rgba(156, 163, 175, 0.3);
            border: 2px solid #9ca3af;
        }

        @media (max-width: 768px) {
            .game-area {
                grid-template-columns: 1fr;
            }
            
            .controls {
                justify-content: center;
            }

            .card {
                width: 50px;
                height: 75px;
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üÉè Blackjack + M√©todos Num√©ricos</h1>
            <p>An√°lisis matem√°tico en tiempo real</p>
        </div>

        <div class="game-area">
            <div class="table">
                <div class="hand" id="dealerHand">
                    <h3>üè† Dealer</h3>
                    <div class="cards" id="dealerCards"></div>
                    <div class="totals">Total: <span id="dealerTotal">-</span></div>
                </div>

                <div class="game-info">
                    <div class="balance">Balance: $<span id="balance">1000</span></div>
                    <div id="gameStatus" class="game-status">Haz clic en "Nuevo Juego" para comenzar</div>
                </div>

                <div class="hand" id="playerHand">
                    <h3>üë§ Jugador</h3>
                    <div class="cards" id="playerCards"></div>
                    <div class="totals">Total: <span id="playerTotal">-</span></div>
                </div>

                <div class="controls">
                    <button onclick="startNewGame()" id="startBtn">Nuevo Juego</button>
                    <button onclick="newHand()" id="newHandBtn" disabled>Nueva Mano</button>
                    <button onclick="hit()" id="hitBtn" disabled>Hit</button>
                    <button onclick="stand()" id="standBtn" disabled>Stand</button>
                    <button onclick="doubleDown()" id="doubleBtn" disabled>Doblar</button>
                </div>

                <div class="bet-input">
                    <label>Apuesta:</label>
                    <input type="number" id="betAmount" value="10" min="1" max="1000">
                </div>
            </div>

            <div class="sidebar">
                <div class="recommendation" id="recommendation">
                    <h4>üßÆ Recomendaci√≥n</h4>
                    <div id="recommendedAction">Haz clic en "Analizar" para obtener recomendaci√≥n</div>
                    <div id="confidence"></div>
                    <button onclick="getRecommendation()" id="analyzeBtn" disabled>Analizar</button>
                </div>

                <div class="stats">
                    <h4>üìä Estad√≠sticas</h4>
                    <div class="stat-item">
                        <span>Manos jugadas:</span>
                        <span id="handsPlayed">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Victorias:</span>
                        <span id="wins">0</span>
                    </div>
                    <div class="stat-item">
                        <span>% Victorias:</span>
                        <span id="winRate">0%</span>
                    </div>
                    <div class="stat-item">
                        <span>Ganancia total:</span>
                        <span id="totalProfit">$0</span>
                    </div>
                </div>

                <div class="numeric-analysis">
                    <h4>üî¢ An√°lisis Num√©rico</h4>
                    <div class="analysis-row">
                        <span>Newton-Raphson:</span>
                        <span id="newtonResult">-</span>
                    </div>
                    <div class="analysis-row">
                        <span>Interpolaci√≥n:</span>
                        <span id="interpolationResult">-</span>
                    </div>
                    <div class="analysis-row">
                        <span>Integraci√≥n:</span>
                        <span id="integrationResult">-</span>
                    </div>
                    <div class="analysis-row">
                        <span>Monte Carlo:</span>
                        <span id="monteCarloResult">-</span>
                    </div>
                </div>

                <canvas id="probabilityChart" width="300" height="200"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Estado del juego
        let gameState = {
            gameStarted: false,
            handInProgress: false,
            playerCards: [],
            dealerCards: [],
            playerTotal: 0,
            dealerTotal: 0,
            balance: 1000,
            currentBet: 0,
            deck: [],
            stats: {
                handsPlayed: 0,
                wins: 0,
                losses: 0,
                draws: 0,
                totalProfit: 0
            }
        };

        let chart;

        // Clase para manejo de cartas
        class Card {
            constructor(suit, rank, value, altValue = null) {
                this.suit = suit;
                this.rank = rank;
                this.value = value;
                this.altValue = altValue;
            }

            isAce() {
                return this.rank === 'A';
            }

            getValue(useAlt = false) {
                return (useAlt && this.altValue) ? this.altValue : this.value;
            }
        }

        // Inicializar mazo
        function initializeDeck() {
            const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
            const ranks = [
                ['A', 1, 11], ['2', 2], ['3', 3], ['4', 4], ['5', 5], ['6', 6],
                ['7', 7], ['8', 8], ['9', 9], ['10', 10], ['J', 10], ['Q', 10], ['K', 10]
            ];

            gameState.deck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    gameState.deck.push(new Card(suit, rank[0], rank[1], rank[2] || null));
                }
            }
            
            // Mezclar mazo
            shuffleDeck();
        }

        function shuffleDeck() {
            for (let i = gameState.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [gameState.deck[i], gameState.deck[j]] = [gameState.deck[j], gameState.deck[i]];
            }
        }

        function dealCard() {
            if (gameState.deck.length === 0) {
                initializeDeck();
            }
            return gameState.deck.pop();
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Calcular total de mano considerando ases
        function calculateHandTotal(cards) {
            let total = 0;
            let aces = 0;

            for (let card of cards) {
                if (card.isAce()) {
                    aces++;
                    total += 11;
                } else {
                    total += card.getValue();
                }
            }

            // Ajustar ases
            while (total > 21 && aces > 0) {
                total -= 10;
                aces--;
            }

            return total;
        }

        // Funciones principales del juego
        function startNewGame() {
            initializeDeck();
            gameState.gameStarted = true;
            gameState.balance = 1000;
            gameState.stats = {
                handsPlayed: 0,
                wins: 0,
                losses: 0,
                draws: 0,
                totalProfit: 0
            };

            document.getElementById('startBtn').disabled = true;
            document.getElementById('newHandBtn').disabled = false;
            updateDisplay();
            updateGameStatus('Juego iniciado. Haz una apuesta para comenzar.', '');
        }

        // C√ìDIGO CORREGIDO - Eliminar la redefinici√≥n problem√°tica al final

        // Funci√≥n newHand corregida (versi√≥n √∫nica)
        function newHand() {
            const betAmount = parseInt(document.getElementById('betAmount').value);
            
            if (betAmount > gameState.balance) {
                updateGameStatus('Fondos insuficientes para esta apuesta.', 'loss');
                return;
            }

            // Configurar nueva mano
            gameState.handInProgress = true;
            gameState.currentBet = betAmount;
            gameState.balance -= betAmount;
            gameState.playerCards = [];
            gameState.dealerCards = [];

            // Repartir cartas iniciales
            gameState.playerCards.push(dealCard());
            gameState.dealerCards.push(dealCard());
            gameState.playerCards.push(dealCard());
            gameState.dealerCards.push(dealCard());

            gameState.playerTotal = calculateHandTotal(gameState.playerCards);
            gameState.dealerTotal = gameState.dealerCards[0].getValue(); // Solo carta visible

            // Actualizar UI
            displayCards('playerCards', gameState.playerCards);
            displayCards('dealerCards', [gameState.dealerCards[0]]); // Solo primera carta
            
            document.getElementById('newHandBtn').disabled = true;
            document.getElementById('hitBtn').disabled = false;
            document.getElementById('standBtn').disabled = false;
            document.getElementById('doubleBtn').disabled = false;
            document.getElementById('analyzeBtn').disabled = false;

            updateDisplay();
            
            // Verificar blackjack
            if (gameState.playerTotal === 21) {
                setTimeout(() => {
                    stand(); // Auto-stand en blackjack
                }, 1000);
                updateGameStatus('¬°Blackjack! Evaluando...', 'win');
            } else {
                updateGameStatus('Tu turno. ¬øHit o Stand?', '');
                // Auto-an√°lisis despu√©s de repartir cartas
                setTimeout(() => {
                    if (gameState.handInProgress && gameState.playerTotal < 21) {
                        getRecommendation();
                    }
                }, 1000);
            }
        }

        function hit() {
            const newCard = dealCard();
            gameState.playerCards.push(newCard);
            gameState.playerTotal = calculateHandTotal(gameState.playerCards);

            // Animaci√≥n de nueva carta
            const newCardElement = createCardElement(newCard);
            newCardElement.classList.add('animation');
            document.getElementById('playerCards').appendChild(newCardElement);

            document.getElementById('doubleBtn').disabled = true;
            updateDisplay();

            if (gameState.playerTotal > 21) {
                endHand('loss', '¬°Te pasaste! Perdiste.');
            } else if (gameState.playerTotal === 21) {
                setTimeout(() => {
                    stand();
                }, 500);
            }
        }

        function stand() {
            // Mostrar carta oculta del dealer
            displayCards('dealerCards', gameState.dealerCards);
            gameState.dealerTotal = calculateHandTotal(gameState.dealerCards);

            // Dealer juega
            while (gameState.dealerTotal < 17) {
                const newCard = dealCard();
                gameState.dealerCards.push(newCard);
                gameState.dealerTotal = calculateHandTotal(gameState.dealerCards);
                
                // Mostrar nuevas cartas del dealer
                setTimeout(() => {
                    displayCards('dealerCards', gameState.dealerCards);
                    updateDisplay();
                }, 500);
            }

            setTimeout(() => {
                evaluateHand();
            }, 1000);
        }

        function doubleDown() {
            if (gameState.balance < gameState.currentBet) {
                updateGameStatus('Fondos insuficientes para doblar.', 'loss');
                return;
            }

            gameState.balance -= gameState.currentBet;
            gameState.currentBet *= 2;

            // Hit obligatorio
            hit();

            // Si no se pas√≥, hacer stand autom√°tico
            if (gameState.playerTotal <= 21) {
                setTimeout(() => {
                    stand();
                }, 1000);
            }
        }

        function evaluateHand() {
            const playerTotal = gameState.playerTotal;
            const dealerTotal = gameState.dealerTotal;
            let result = '';
            let multiplier = 0;
            let message = '';

            if (playerTotal > 21) {
                result = 'loss';
                message = '¬°Te pasaste! Perdiste.';
            } else if (dealerTotal > 21) {
                result = 'win';
                multiplier = 1;
                message = '¬°El dealer se pas√≥! Ganaste.';
            } else if (playerTotal === 21 && gameState.playerCards.length === 2 && dealerTotal !== 21) {
                result = 'blackjack';
                multiplier = 1.5;
                message = '¬°Blackjack! Ganaste con bonificaci√≥n.';
            } else if (dealerTotal === 21 && gameState.dealerCards.length === 2 && playerTotal !== 21) {
                result = 'loss';
                message = 'El dealer tiene blackjack. Perdiste.';
            } else if (playerTotal > dealerTotal) {
                result = 'win';
                multiplier = 1;
                message = '¬°Ganaste con mayor puntuaci√≥n!';
            } else if (playerTotal < dealerTotal) {
                result = 'loss';
                message = 'El dealer gan√≥ con mayor puntuaci√≥n.';
            } else {
                result = 'draw';
                gameState.balance += gameState.currentBet; // Recuperar apuesta
                message = 'Empate. Recuperas tu apuesta.';
            }

            if (result === 'win' || result === 'blackjack') {
                const winnings = gameState.currentBet * (1 + multiplier);
                gameState.balance += winnings;
                gameState.stats.wins++;
                gameState.stats.totalProfit += (winnings - gameState.currentBet);
            } else if (result === 'loss') {
                gameState.stats.losses++;
                gameState.stats.totalProfit -= gameState.currentBet;
            } else {
                gameState.stats.draws++;
            }

            endHand(result, message);
        }

        function endHand(result, message) {
            gameState.handInProgress = false;
            gameState.stats.handsPlayed++;
            
            document.getElementById('hitBtn').disabled = true;
            document.getElementById('standBtn').disabled = true;
            document.getElementById('doubleBtn').disabled = true;
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('newHandBtn').disabled = false;

            updateGameStatus(message, result);
            updateDisplay();
            updateStats();

            // Reset para pr√≥xima mano
            gameState.currentBet = 0;
        }

        // Funciones de an√°lisis num√©rico
        function getRecommendation() {
            const analysis = performNumericAnalysis();
            
            const recDiv = document.getElementById('recommendation');
            const actionDiv = document.getElementById('recommendedAction');
            const confidenceDiv = document.getElementById('confidence');

            actionDiv.innerHTML = `<strong>${analysis.recommendation.toUpperCase()}</strong>`;
            confidenceDiv.innerHTML = `Confianza: ${(analysis.confidence * 100).toFixed(1)}%`;

            recDiv.className = 'recommendation ' + analysis.recommendation;

            // Actualizar an√°lisis num√©rico
            document.getElementById('newtonResult').textContent = analysis.newton_raphson.toFixed(4);
            document.getElementById('interpolationResult').textContent = analysis.interpolation.toFixed(4);
            document.getElementById('integrationResult').textContent = analysis.integration.toFixed(4);
            document.getElementById('monteCarloResult').textContent = analysis.monte_carlo.toFixed(4);

            updateProbabilityChart(analysis);
        }

        function performNumericAnalysis() {
            const playerTotal = gameState.playerTotal;
            const dealerVisible = gameState.dealerCards[0].getValue();

            // Newton-Raphson para probabilidad √≥ptima
            const newtonResult = newtonRaphsonOptimalProbability(playerTotal, dealerVisible);
            
            // Interpolaci√≥n de Newton
            const interpolationResult = newtonInterpolation(playerTotal, dealerVisible);
            
            // Integraci√≥n trapezoidal
            const integrationResult = trapezoidalIntegration(playerTotal, dealerVisible);
            
            // Monte Carlo
            const monteCarloResult = monteCarloSimulation(playerTotal, dealerVisible, 1000);

            // Determinar recomendaci√≥n final
            const hitProbability = (newtonResult + interpolationResult + monteCarloResult) / 3;
            const recommendation = hitProbability > 0.5 ? 'hit' : 'stand';
            const confidence = Math.abs(hitProbability - 0.5) * 2;

            return {
                recommendation,
                confidence,
                newton_raphson: newtonResult,
                interpolation: interpolationResult,
                integration: integrationResult,
                monte_carlo: monteCarloResult
            };
        }

        // Implementaci√≥n de m√©todos num√©ricos
        function newtonRaphsonOptimalProbability(playerTotal, dealerVisible) {
            // Simplificado: probabilidad basada en estrategia b√°sica
            if (playerTotal <= 11) return 0.9;
            if (playerTotal >= 17) return 0.1;
            
            const bustProbability = getBustProbability(playerTotal);
            const dealerBustProb = getDealerBustProbability(dealerVisible);
            
            return Math.max(0.1, Math.min(0.9, dealerBustProb - bustProbability + 0.5));
        }

        function newtonInterpolation(playerTotal, dealerVisible) {
            // Puntos conocidos de probabilidad de √©xito
            const knownPoints = [
                {x: 12, y: 0.31}, {x: 15, y: 0.38}, {x: 18, y: 0.67}, {x: 20, y: 0.85}
            ];
            
            // Interpolaci√≥n lineal simple
            for (let i = 0; i < knownPoints.length - 1; i++) {
                if (playerTotal >= knownPoints[i].x && playerTotal <= knownPoints[i + 1].x) {
                    const t = (playerTotal - knownPoints[i].x) / (knownPoints[i + 1].x - knownPoints[i].x);
                    return knownPoints[i].y + t * (knownPoints[i + 1].y - knownPoints[i].y);
                }
            }
            
            return playerTotal <= 12 ? 0.31 : 0.85;
        }

        function trapezoidalIntegration(playerTotal, dealerVisible) {
            // Integrar funci√≥n de probabilidad acumulada
            const a = 0, b = 1;
            const n = 100;
            const h = (b - a) / n;
            
            let sum = probabilityDensity(a, playerTotal) + probabilityDensity(b, playerTotal);
            
            for (let i = 1; i < n; i++) {
                const x = a + i * h;
                sum += 2 * probabilityDensity(x, playerTotal);
            }
            
            return (h / 2) * sum;
        }

        function monteCarloSimulation(playerTotal, dealerVisible, iterations) {
            let wins = 0;
            
            for (let i = 0; i < iterations; i++) {
                const simResult = simulateHand(playerTotal, dealerVisible);
                if (simResult) wins++;
            }
            
            return wins / iterations;
        }

        // Funciones auxiliares
        function getBustProbability(playerTotal) {
            const cardsLeft = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10]; // A-K
            let bustCards = 0;
            
            for (let card of cardsLeft) {
                if (playerTotal + card > 21) bustCards++;
            }
            
            return bustCards / cardsLeft.length;
        }

        function getDealerBustProbability(dealerVisible) {
            const bustProbs = {
                2: 0.35, 3: 0.37, 4: 0.40, 5: 0.42, 6: 0.42,
                7: 0.26, 8: 0.24, 9: 0.23, 10: 0.21, 11: 0.11
            };
            return bustProbs[dealerVisible] || 0.25;
        }

        function probabilityDensity(x, playerTotal) {
            // Funci√≥n de densidad simplificada
            const optimal = playerTotal >= 17 ? 0.2 : 0.8;
            const variance = 0.1;
            return Math.exp(-Math.pow(x - optimal, 2) / (2 * variance));
        }

        function simulateHand(playerTotal, dealerVisible) {
            // Simular hit
            const newCard = Math.floor(Math.random() * 10) + 1;
            const newTotal = playerTotal + newCard;
            
            if (newTotal > 21) return false;
            
            // Simular dealer
            let dealerTotal = dealerVisible + Math.floor(Math.random() * 10) + 1;
            while (dealerTotal < 17) {
                dealerTotal += Math.floor(Math.random() * 10) + 1;
            }
            
            if (dealerTotal > 21) return true;
            return newTotal > dealerTotal;
        }

        // Funciones de UI
        function displayCards(containerId, cards) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            cards.forEach((card, index) => {
                const cardElement = createCardElement(card);
                if (index === cards.length - 1) {
                    cardElement.classList.add('animation');
                }
                container.appendChild(cardElement);
            });
        }

        function createCardElement(card) {
            const cardDiv = document.createElement('div');
            cardDiv.className = `card ${card.suit}`;
            cardDiv.innerHTML = `
                <div>${card.rank}</div>
                <div style="text-align: center;">${getSuitSymbol(card.suit)}</div>
                <div style="transform: rotate(180deg)">${card.rank}</div>
            `;
            return cardDiv;
        }

        function getSuitSymbol(suit) {
            const symbols = {
                hearts: '‚ô•',
                diamonds: '‚ô¶',
                clubs: '‚ô£',
                spades: '‚ô†'
            };
            return symbols[suit] || '?';
        }

        function updateDisplay() {
            document.getElementById('balance').textContent = gameState.balance;
            document.getElementById('playerTotal').textContent = gameState.playerTotal || '-';
            document.getElementById('dealerTotal').textContent = gameState.handInProgress ? 
                gameState.dealerCards[0].getValue() : (gameState.dealerTotal || '-');
        }

        function updateGameStatus(message, type) {
            const statusDiv = document.getElementById('gameStatus');
            statusDiv.textContent = message;
            statusDiv.className = `game-status ${type}`;
        }

        function updateStats() {
            document.getElementById('handsPlayed').textContent = gameState.stats.handsPlayed;
            document.getElementById('wins').textContent = gameState.stats.wins;
            document.getElementById('winRate').textContent = 
                gameState.stats.handsPlayed > 0 ? 
                ((gameState.stats.wins / gameState.stats.handsPlayed) * 100).toFixed(1) + '%' : '0%';
            
            // CORRECCI√ìN: Agregar el s√≠mbolo de d√≥lar correctamente
            const profit = gameState.stats.totalProfit;
            const profitText = profit >= 0 ? `+${profit}` : `-${Math.abs(profit)}`;
            document.getElementById('totalProfit').textContent = profitText;
        }

        function updateProbabilityChart(data) {
            const ctx = document.getElementById('probabilityChart').getContext('2d');
            
            // Destruir gr√°fico anterior de forma m√°s eficiente
            if (chart) {
                chart.destroy();
                chart = null;
            }
            
            const chartData = {
                labels: ['Newton-Raphson', 'Interpolaci√≥n', 'Integraci√≥n', 'Monte Carlo'],
                datasets: [{
                    label: 'Probabilidad de √âxito',
                    data: [
                        data.newton_raphson || 0,
                        data.interpolation || 0,
                        data.integration || 0,
                        data.monte_carlo || 0
                    ],
                    backgroundColor: [
                        'rgba(34, 197, 94, 0.8)',
                        'rgba(59, 130, 246, 0.8)',
                        'rgba(245, 158, 11, 0.8)',
                        'rgba(168, 85, 247, 0.8)'
                    ],
                    borderColor: [
                        'rgba(34, 197, 94, 1)',
                        'rgba(59, 130, 246, 1)',
                        'rgba(245, 158, 11, 1)',
                        'rgba(168, 85, 247, 1)'
                    ],
                    borderWidth: 2
                }]
            };
            
            chart = new Chart(ctx, {
                type: 'bar',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: 'An√°lisis Comparativo',
                            color: 'white'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 1,
                            ticks: {
                                color: 'white',
                                callback: function(value) {
                                    return (value * 100).toFixed(0) + '%';
                                }
                            },
                            grid: {
                                color: 'rgba(255,255,255,0.1)'
                            }
                        },
                        x: {
                            ticks: {
                                color: 'white',
                                maxRotation: 45,
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                color: 'rgba(255,255,255,0.1)'
                            }
                        }
                    },
                    // Reducir animaci√≥n para mejorar rendimiento
                    animation: {
                        duration: 500,
                        easing: 'easeInOutQuart'
                    },
                    // Desactivar interacciones innecesarias
                    interaction: {
                        intersect: false
                    }
                }
            });
        }

        // Eventos de teclado
        document.addEventListener('keydown', function(e) {
            if (!gameState.handInProgress) return;
            
            switch(e.key.toLowerCase()) {
                case 'h':
                    if (!document.getElementById('hitBtn').disabled) hit();
                    break;
                case 's':
                    if (!document.getElementById('standBtn').disabled) stand();
                    break;
                case 'd':
                    if (!document.getElementById('doubleBtn').disabled) doubleDown();
                    break;
                case 'a':
                    if (!document.getElementById('analyzeBtn').disabled) getRecommendation();
                    break;
                case 'n':
                    if (!document.getElementById('newHandBtn').disabled) newHand();
                    break;
            }
        });

        // Auto-analizar cuando comience una nueva mano
        function autoAnalyze() {
            if (gameState.handInProgress && gameState.playerTotal < 21) {
                setTimeout(() => {
                    getRecommendation();
                }, 1000);
            }
        }

        // Funciones adicionales de m√©todos num√©ricos avanzados

        // M√©todo de Bisecci√≥n para encontrar probabilidad √≥ptima
        function bisectionMethod(playerTotal, dealerVisible, tolerance = 0.0001) {
            let a = 0, b = 1;
            let iterations = 0;
            const maxIterations = 100;

            while ((b - a) / 2 > tolerance && iterations < maxIterations) {
                const c = (a + b) / 2;
                const fc = expectedValueFunction(c, playerTotal, dealerVisible);
                
                if (fc === 0) break;
                
                if (expectedValueFunction(a, playerTotal, dealerVisible) * fc < 0) {
                    b = c;
                } else {
                    a = c;
                }
                iterations++;
            }
            
            return (a + b) / 2;
        }

        // Funci√≥n de valor esperado para m√©todos num√©ricos
        function expectedValueFunction(prob, playerTotal, dealerVisible) {
            const hitExpected = calculateHitExpectedValue(playerTotal, dealerVisible);
            const standExpected = calculateStandExpectedValue(playerTotal, dealerVisible);
            return prob * hitExpected + (1 - prob) * standExpected;
        }

        function calculateHitExpectedValue(playerTotal, dealerVisible) {
            let expectedValue = 0;
            const possibleCards = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10];
            
            for (let card of possibleCards) {
                const newTotal = playerTotal + card;
                const probability = 1 / possibleCards.length;
                
                if (newTotal > 21) {
                    expectedValue += probability * (-1); // Bust
                } else {
                    expectedValue += probability * calculateStandExpectedValue(newTotal, dealerVisible);
                }
            }
            
            return expectedValue;
        }

        function calculateStandExpectedValue(playerTotal, dealerVisible) {
            const dealerBustProb = getDealerBustProbability(dealerVisible);
            let expectedValue = dealerBustProb * 1; // Win if dealer busts
            
            // Approximate dealer final totals
            const dealerTotals = {17: 0.13, 18: 0.13, 19: 0.13, 20: 0.13, 21: 0.12};
            
            for (let [total, prob] of Object.entries(dealerTotals)) {
                if (playerTotal > parseInt(total)) {
                    expectedValue += prob * 1; // Win
                } else if (playerTotal < parseInt(total)) {
                    expectedValue += prob * (-1); // Loss
                }
                // Draw = 0, no change
            }
            
            return expectedValue;
        }

        // Algoritmo gen√©tico para optimizaci√≥n de estrategia
        function geneticAlgorithmStrategy(playerTotal, dealerVisible) {
            const populationSize = 50;
            const generations = 20;
            let population = [];
            
            // Initialize population
            for (let i = 0; i < populationSize; i++) {
                population.push({
                    hitThreshold: Math.random(),
                    dealerFactor: Math.random(),
                    fitness: 0
                });
            }
            
            // Evolution
            for (let gen = 0; gen < generations; gen++) {
                // Evaluate fitness
                for (let individual of population) {
                    individual.fitness = evaluateStrategyFitness(individual, playerTotal, dealerVisible);
                }
                
                // Selection and crossover
                population.sort((a, b) => b.fitness - a.fitness);
                const newPopulation = population.slice(0, populationSize / 2);
                
                while (newPopulation.length < populationSize) {
                    const parent1 = population[Math.floor(Math.random() * populationSize / 2)];
                    const parent2 = population[Math.floor(Math.random() * populationSize / 2)];
                    
                    const child = {
                        hitThreshold: (parent1.hitThreshold + parent2.hitThreshold) / 2,
                        dealerFactor: (parent1.dealerFactor + parent2.dealerFactor) / 2,
                        fitness: 0
                    };
                    
                    // Mutation
                    if (Math.random() < 0.1) {
                        child.hitThreshold += (Math.random() - 0.5) * 0.2;
                        child.dealerFactor += (Math.random() - 0.5) * 0.2;
                    }
                    
                    newPopulation.push(child);
                }
                
                population = newPopulation;
            }
            
            return population[0].hitThreshold;
        }

        function evaluateStrategyFitness(strategy, playerTotal, dealerVisible) {
            const hitProb = strategy.hitThreshold * (1 + strategy.dealerFactor * getDealerBustProbability(dealerVisible));
            const expectedValue = expectedValueFunction(hitProb, playerTotal, dealerVisible);
            return expectedValue;
        }

        // Redes neuronales b√°sicas para predicci√≥n
        function neuralNetworkPrediction(playerTotal, dealerVisible) {
            // Simplified neural network with hardcoded weights
            const input = [playerTotal / 21, dealerVisible / 11];
            
            // Hidden layer
            const hidden = [
                Math.tanh(input[0] * 0.5 + input[1] * 0.3 - 0.2),
                Math.tanh(input[0] * -0.4 + input[1] * 0.6 + 0.1),
                Math.tanh(input[0] * 0.7 + input[1] * -0.2 + 0.3)
            ];
            
            // Output layer
            const output = Math.sigmoid(hidden[0] * 0.4 + hidden[1] * 0.3 + hidden[2] * 0.5 - 0.1);
            
            return output;
        }

        Math.sigmoid = function(x) {
            return 1 / (1 + Math.exp(-x));
        };

        // Sistema experto para recomendaciones
        function expertSystemRecommendation(playerTotal, dealerVisible) {
            const rules = [
                // Reglas b√°sicas
                {condition: () => playerTotal <= 8, action: 'hit', confidence: 1.0},
                {condition: () => playerTotal >= 17, action: 'stand', confidence: 1.0},
                {condition: () => playerTotal === 11, action: 'double', confidence: 0.9},
                {condition: () => playerTotal === 10 && dealerVisible <= 9, action: 'double', confidence: 0.8},
                {condition: () => playerTotal === 9 && dealerVisible >= 3 && dealerVisible <= 6, action: 'double', confidence: 0.7},
                
                // Reglas condicionales
                {condition: () => playerTotal >= 12 && playerTotal <= 16 && dealerVisible >= 2 && dealerVisible <= 6, action: 'stand', confidence: 0.8},
                {condition: () => playerTotal >= 12 && playerTotal <= 16 && dealerVisible >= 7, action: 'hit', confidence: 0.7},
                
                // Reglas avanzadas
                {condition: () => playerTotal === 16 && dealerVisible === 10, action: 'hit', confidence: 0.6},
                {condition: () => playerTotal === 12 && dealerVisible >= 4 && dealerVisible <= 6, action: 'stand', confidence: 0.75}
            ];
            
            for (let rule of rules) {
                if (rule.condition()) {
                    return {action: rule.action, confidence: rule.confidence};
                }
            }
            
            return {action: 'hit', confidence: 0.5}; // Default
        }

        // Integraci√≥n de todos los m√©todos para recomendaci√≥n final
        function advancedRecommendationSystem() {
            const playerTotal = gameState.playerTotal;
            const dealerVisible = gameState.dealerCards[0].getValue();
            
            // Ejecutar todos los m√©todos
            const newton = newtonRaphsonOptimalProbability(playerTotal, dealerVisible);
            const interpolation = newtonInterpolation(playerTotal, dealerVisible);
            const integration = trapezoidalIntegration(playerTotal, dealerVisible);
            const monteCarlo = monteCarloSimulation(playerTotal, dealerVisible, 1000);
            const bisection = bisectionMethod(playerTotal, dealerVisible);
            const genetic = geneticAlgorithmStrategy(playerTotal, dealerVisible);
            const neural = neuralNetworkPrediction(playerTotal, dealerVisible);
            const expert = expertSystemRecommendation(playerTotal, dealerVisible);
            
            // Pesos para cada m√©todo
            const weights = {
                newton: 0.2,
                interpolation: 0.15,
                integration: 0.15,
                monteCarlo: 0.2,
                bisection: 0.1,
                genetic: 0.05,
                neural: 0.1,
                expert: 0.05
            };
            
            // Calcular puntuaci√≥n ponderada
            const hitScore = 
                newton * weights.newton +
                interpolation * weights.interpolation +
                integration * weights.integration +
                monteCarlo * weights.monteCarlo +
                bisection * weights.bisection +
                genetic * weights.genetic +
                neural * weights.neural +
                (expert.action === 'hit' ? expert.confidence : 0) * weights.expert;
            
            const standScore = 1 - hitScore;
            
            let recommendation, confidence;
            
            if (expert.action === 'double' && gameState.playerCards.length === 2) {
                recommendation = 'double';
                confidence = expert.confidence;
            } else if (hitScore > standScore) {
                recommendation = 'hit';
                confidence = hitScore;
            } else {
                recommendation = 'stand';
                confidence = standScore;
            }
            
            return {
                recommendation,
                confidence: Math.min(confidence, 1.0),
                methods: {
                    newton,
                    interpolation,
                    integration,
                    monte_carlo: monteCarlo,
                    bisection,
                    genetic,
                    neural,
                    expert: expert.action === 'hit' ? expert.confidence : (1 - expert.confidence)
                }
            };
        }

        // Modificar la funci√≥n getRecommendation para usar el sistema avanzado
        function getRecommendation() {
                    const getRecommendationDebounced = debounce(function() {
            const analysis = advancedRecommendationSystem();
            
            const recDiv = document.getElementById('recommendation');
            const actionDiv = document.getElementById('recommendedAction');
            const confidenceDiv = document.getElementById('confidence');

            actionDiv.innerHTML = `<strong>${analysis.recommendation.toUpperCase()}</strong>`;
            confidenceDiv.innerHTML = `Confianza: ${(analysis.confidence * 100).toFixed(1)}%`;

            recDiv.className = 'recommendation ' + analysis.recommendation;

            // Actualizar an√°lisis num√©rico con m√°s m√©todos
            document.getElementById('newtonResult').textContent = analysis.methods.newton.toFixed(4);
            document.getElementById('interpolationResult').textContent = analysis.methods.interpolation.toFixed(4);
            document.getElementById('integrationResult').textContent = analysis.methods.integration.toFixed(4);
            document.getElementById('monteCarloResult').textContent = analysis.methods.monte_carlo.toFixed(4);

            updateProbabilityChart(analysis.methods);
        }, 300); // Esperar 300ms entre llamadas
        }

        // Inicializaci√≥n mejorada
        document.addEventListener('DOMContentLoaded', function() {
            updateGameStatus('Haz clic en "Nuevo Juego" para comenzar', '');
            
            // Mostrar informaci√≥n de controles
            console.log('Controles de teclado:');
            console.log('H - Hit');
            console.log('S - Stand');
            console.log('D - Doblar');
            console.log('A - Analizar');
            console.log('N - Nueva Mano');
            
            // Inicializar gr√°fico vac√≠o
            updateProbabilityChart({
                newton_raphson: 0,
                interpolation: 0,
                integration: 0,
                monte_carlo: 0
            });
        });

        // Override de la funci√≥n newHand para incluir auto-an√°lisis
        const originalNewHand = newHand;
        newHand = function() {
            originalNewHand();
            if (gameState.handInProgress) {
                autoAnalyze();
            }
        };
    </script>
</body>
</html>